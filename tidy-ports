#!/bin/sh
#
#	tidy-ports
#
#	Remove the inactive ports from the current MacPorts installation
#	
#   Â© 2012 Alan Staniforth
#
#	Version 1.0
#
#	Invoke thus:
#
#	./tidy-ports	[-h|-v]
#

# Version
TIDY_VERS=1.0

### Set up.
# Set trap to allow abort on signal: 
trap 'echo "Interrupted by signal" >&2; exit' 1 2 3 15

### Constants

### Variables

### Process the options if any

if test $# -ne 0 ; then
	### Options
	while test $# -gt 0;
	do
		### Get the option flag and switch on that basis
		case "$1" in
			-*) FLAG="$1" 
				case "$FLAG" in
					-h) 
						### Usage information
						echo "Usage: ./tidy-ports [NUM_BEEPS]"
						echo "Usage: ./tidy-ports -h"
						echo "Usage: ./tidy-ports -v"
						echo ""
						echo "Options:"
						echo "    -h        Print this usage summary."
						echo "    -v        Print tool version."
						echo ""
						echo "Description:"
						echo "    Remove the inactive ports from the current MacPorts installation"
						echo ""
						NOBUILD=true
						break
					;;
					-v) 
						### version
						echo "$TIDY_VERS"
						NOBUILD=true
						break
					;;
					-*) echo "Usage: "$1" not understood!"
						echo "Use sw-bind -h for usage information"
						NOBUILD=true
						break
					;;
				esac
			;;
			*) 
				BEEP_NUMBER="$1"
				if ! [ "$BEEP_NUMBER" -gt "0" ] ; then
					echo "Usage: "$1" not understood! Any parameter must be a number."
					echo "Use beep -h for usage information"
					NOBUILD=true
				fi
				break
			;;
		esac
		shift
	done
fi

### Bale out if bad option or not called to build, just for info

if test $NOBUILD ; then
	exit
fi

### Actual functionality implemented here.

### get a list of the currently installed ports, both active and deactivated.
portlist="`port installed`"

### declare variables
declare -a inactive_port_list 		# declare an array - not strictly necessary
inactive_port_count=0				# count of entries in the array

### What follows wa originally written like this:
# 
# echo "${portlist}" |
# while read port_info
# do
# 	...
# done
# 
# Unfortunately there is a problem with this. Processes put together with a pipe are 
# executed in subshells (and therefore have their own environment). Whatever happens 
# within the while does not affect anything outside of the pipe. So the variables 
# manipulated within the while are purely local to that subshell environmant and the
# same named variables in the script are not affected
# 
# Below are two ways to fix this. I have kept both for the sake of future reference 
# with one commented out. I chose the active one because it is slightly neater and 
# I don't like creating temporary files if I can avoid it. Both work well though.
# 
### Iterate through each port, adding it to an array if it is found to be inactive
while read port_info
do
	port_info_stripped="${port_info%% (active)}"
	pi_len=`expr "$port_info" : '.*'`
	pi_stripped_len=`expr "$port_info_stripped" : '.*'`
	
	if [[ pi_len -eq pi_stripped_len ]] ; then
		echo "${port_info} (inactive)"
		echo "inactive_port_count is: ${inactive_port_count}"
		inactive_port_list[$inactive_port_count]="${port_info}"
		echo "inactive_port_list[${inactive_port_count}] is: ${inactive_port_list[$inactive_port_count]}"
		let "inactive_port_count += 1"
	else
		echo "${port_info}"
	fi
done <<< "$portlist"

### Alternate form of loop to deal with problem of a pipe creating a subshell
# echo "${portlist}" > "/tmp/${UID}/installed.txt"
# exec 3<> /tmp/${UID}/installed.txt
# while read port_info <&3
# do
#  	port_info_stripped="${port_info%% (active)}"
#  	pi_len=`expr "$port_info" : '.*'`
#  	pi_stripped_len=`expr "$port_info_stripped" : '.*'`
#  	
#  	if [[ pi_len -eq pi_stripped_len ]] ; then
#  		echo "${port_info} (inactive)"
#  		echo "inactive_port_count is: ${inactive_port_count}"
#  		inactive_port_list[$inactive_port_count]="${port_info}"
#  		echo "inactive_port_list[${inactive_port_count}] is: ${inactive_port_list[$inactive_port_count]}"
#  		let "inactive_port_count += 1"
#  	else
#  		echo "${port_info}"
#  	fi
# done
# exec 3>&-
# rm /tmp/${UID}/installed.txt

if [[ $inactive_port_count -gt 0 ]] ; then
	echo ${#inactive_port_list[*]}
	echo ${#inactive_port_list[@]}
 	inactive_port_index=0
	while [ $inactive_port_index -lt $inactive_port_count ]
	do
		echo "inactive_port is: ${inactive_port_list[$inactive_port_index]}"
 		part_count=1
 		for part_info in "${inactive_port_list[$inactive_port_index]}"
		do
			cli[$part_count]="${part_info}"
			let "part_count += 1"
		done
		
		echo "sudo port -f uninstall  ${cli[1]} ${cli[2]}"
		echo "sudo port clean --logs --work ${cli[1]}"
		
 		let "inactive_port_index += 1"
	done
fi
